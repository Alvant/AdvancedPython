# Lab 6. Magic

![](./images/SpongeBob-Pythonbow.png)

Достаточно решить любую задачу без звёздочки (от задачи номер 1 до задачи номер 5).



## Задача 1 («‎Библиотека»‎)

В библиотеках хранятся книги.
У каждой книги есть название, а также автор, и дата выпуска.
У каждой библиотеки тоже есть название.
В библиотеке может быть больше одного экземпляра книги с теми же названием и автором.
Надо определить классы для **Книги** и **Библиотеки**.

При этом должна быть возможность добавить книгу в библиотеку с помощью операции `+`.
При сложении библиотеки и книги получается новая библиотека с тем же названием, что у библиотеки-слагаемого, но у которой среди книг есть ещё одна — книга-слагаемое:
Например:
```python
biblio = Library(name="Библиотека МФТИ")
book = Book(
    name="Теоретическая физика. Том 1. Механика",
	author="Ландау Л.Д., Лифшиц Е.М.",
	year=2004
)

biblio = biblio + book
# Теперь в библиотеке biblio на одну книгу больше
```

Должна быть возможность сравнить две библиотеки: считается, что одна библиотека "больше" другой, если в ней больше книг.
Две библиотеки равны, если в них содержатся одинаковые наборы книг
(книги, в свою очередь, считаются одинаковыми, если у них одинаковые названия и автор).
Например:
```python
biblio1 = Library(name="Библиотека МФТИ")
biblio2 = Library(name="Ленинка")
book = Book(
    name="Теоретическая физика. Том 1. Механика",
	author="Ландау Л.Д., Лифшиц Е.М.",
	year=2004
)

biblio1 = biblio1 + book
biblio2 = biblio2 + book

print(biblio1 > biblio2)   # False
print(biblio1 == biblio2)  # True, так как 1 == 1

biblio1 += book

print(biblio1 > biblio2)   # True, так как 2 > 1
print(biblio1 == biblio2)  # False
```

У библиотеки должен быть "читаемый" вывод как при использовании `print`.
Например:
```python
biblio = Library(name="Библиотека МФТИ")
book = Book(
    name="Теоретическая физика. Том 1. Механика",
	author="Ландау Л.Д., Лифшиц Е.М.",
	year=2004
)

biblio = biblio + book

print(biblio)  # Библиотека МФТИ (число книг: 1)
```
Так и при "выводе в ячейке".
Например (для библиотеки из предыдущего примера):
```python
print(repr(biblio))  # Library(name="Библиотека МФТИ")
```


## Задача 2 («‎ℚ»‎)

Нужно определить класс **Рационального числа**: в классе должны быть методы по сложению, вычитанию, умножению и делению рациональных чисел.
Также должен быть метод по переводу рационального числа в обычное `float` число (например объект, представляющий число `1/8` должен отобразиться в `0.125`).
И ещё надо реализовать *классовый* метод по созданию объекта рационального числа из строки вида `"n/m"` (например `"3/4"`).
Например:
```python
r1 = Rational(1, 2)
r2 = Rational(-1, 2)

print(r1 * r2)    # -1/4
print(float(r1))  # 0.5

print(Rational.from_string('3/4'))  # 3/4
```

Напишите тест (в виде отдельной функции), в котором надо создать два рациональных числа и проверить операции сложения, вычитания, деления и умножения на их примере.
Напишите тест для проверки перевода рационального числа во `float` число.
И тест для проверки создания рационального числа по строке.

То есть весь код в итоге должен выглядеть как-то так:
```python
class Rational:
    pass  # TODO: code here


def test_operations():
    pass  # TODO: test here


def test_cast_to_float():
    pass  # TODO: test here


def test_parse_from_string():
    pass  # TODO: test here


if __name__ == '__main__':
    test_operations()
    test_cast_to_float()
    test_parse_from_string()
```

### P.S.

Проверки внутри, например, `test_operations` можно делать с помощью `assert`:
```python
assert Rational(1, 2) + Rational(1, 2) == Rational(1, 1)
```


## Задача 3 («‎CustomDict»‎)

Реализуйте свой словарь (назовём его, например, `CustomDict`).
Он должен поддерживать методы, которые есть в обычном Python словаре (и у него должен быть читаемый вывод на экран; например, такой же, как и у обычного словаря):
```python
data = CustomDict()

data['johnny'] = 'depp'
data['margot'] = 'robbie'
 
print(data)       # {'johnny': 'depp', 'margot': 'robbie'}
print(len(data))  # 2

del data['johnny']
 
print(len(data))        # 1
print('johnny' in data) # False
print('margot' in data) # True
```

Помимо функционала обычного словаря, надо реализовать сложение объектов типа `CustomDict` с помощью оператора `+`: словарь-результат типа `CustomDict` должен содержать все ключи, которые есть в первом и втором словарях, при этом значения по общим ключам должны совпадать со значениями из второго словаря
(то есть суть операции `+` в том, что прибавляемый словарь *обновляет и дополняет* информацию в первом словаре).
При этом в качестве второго операнда может выступать и обычный Python словарь.
Например:
```python
data1 = CustomDict('a'=1)
data2 = CustomDict('b'=2)

print(data1 + data2)     # {'a': 1, 'b': 2}
print(data1 + {'b': 2})  # {'a': 1, 'b': 2}
```

Также надо написать классовый метод `CustomDict.from_default`, который создаёт объект класса `CustomDict` по обычному словарю:
```python
data = CustomDict.from_default({'time': '23:29', 'doing': 'writing hw'})

print(data)  # {'time': '23:29', 'doing': 'writing hw'}
```


## Задача 4 («Точки в полярных кооринатах»‎)

Надо реализовать класс `Point` для представления точек в [полярной системе координат](https://en.wikipedia.org/wiki/Polar_coordinate_system) на плоскости.
Точка в порярной системе координат определяется расстоянием до полюса *r* и углом *φ* между направлением на точку из полюса и заранее выбранным направлением **l**.
Расстояние будем считать безразмерным, а угол — выраженным в градусах.
Например, создание объекта, представляющего точку, удалённую от полюса на расстояние 10 под углом в 30 градусов:
```python
p = Point(r=10, phi=30)
```

Должна быть возможность складывать точки.
При сложении двух точек складываются их радиусы-векторы по правилу сложения векторов.
И координатами точки-результата будут: длина результирующего вектора и угол, который он образует с направлением **l**.
Например:
```python
p1 = Point(r=1, phi=0)
p2 = Point(r=1, phi=90)
p3 = p1 + p2
# p3 — точка с r = 1.41 (примерно) и phi = 45
```

Также должна быть возможность создать объект точки не только по радиусу и углу, но и по "обычным" координатам.
То есть по координатам точки в декартовой прямоугольной системе координат, начало которой совпадает с началом полярной системы, а ось OX сонаправлена с **l**.
Например:
```python
p = Point.from_cartesian(x=-17.5, y=0)
# Создаётся точка с r = 17.5 и phi = 180
```

У точки `Point` должно быть понятное представление как при выводе с помощью `print`.
Например:
```python
p = Point(1, 10)

print(p)  # (r = 1, φ = 10)
```
Так и при "выводе в ячейке".
Например:
```python
p = Point(1, 10)

print(repr(p))  # Point(1, 10)
```

Также должна быть возможность проверить две точки на равенство.
Объекты класса `Point` точки `p1` и `p2` равны, если они представляют одну и ту же точку плоскости:
```python
p1 = Point(1, 120)
p2 = Point(1, 480)

print(p1 == p2)  # True
```


## Задача 5 («‎OrderedDict»‎)

Обычные словари в Питоне (по крайней мере до определённой версии языка) не гарантировали никакого порядка на ключах.
Это значит, что, например, если записать в словарь сначала некоторое значение под ключом `k1`, а потом значение под ключом `k2`, то это не обязательно означает, что в словаре `k1` идёт перед `k2`.

Реализуйте словарь, где *ключи всегда будут упорядочены* (назовём его`OrderedDict`).

Он должен поддерживать методы, которые есть в обычном Python словаре (и у него должен быть читаемый вывод на экран; например, такой же, как и у обычного словаря):
```python
data = OrderedDict()

data['b'] = 'margot robbie'
data['a'] = 'johnny depp'
 
print(data)       # {'a': 'johnny depp', 'b': 'margot robbie'}
print(len(data))  # 2

del data['a']
 
print(len(data))    # 1
print('a' in data)  # False
print('b' in data)  # True
```

Также надо написать классовый метод `OrderedDict.from_default`, который создаёт объект класса `OrderedDict` по обычному словарю:
```python
data = OrderedDict.from_default({'time': '23:29', 'doing': 'writing hw'})

print(data)  # {'doing': 'writing hw', 'time': '23:29'}
```


## Задача 6* («‎Secret Storage»‎)

Напишите класс `Storage`, который при создании принимает на вход какую-то информацию в виде словаря.
При этом у объектов класса `Storage` должны быть приватные атрибуты `_reserve_data` и `_secret_data` — тоже словари, фиксированные.
Например, конструктор класса `Storage` может выглядеть так:
```python
from typing import Any, Dict


class Storage:
    def __init__(self, data: Dict[str, Any]):
        self._data = data
        self._reserve_data = {
            "potato": 100,
        }
        self._secret_data = {
            "supplier": "johnny",
        }
```

Надо сделать так, чтобы можно было обращаться по ключу к объекту класса `Storage`. При этом
* если ключ есть в `_data`, то должно возвращаться значение из переданного при создании объекта словаря
* если ключа нет в `_data`, то должен произойти поиск ключа в `_reserve_data`, и, если ключ есть там, возвращается соответствующее значение из `_reserve_data`
* если же ключа нет ни в `_data`, ни в `_reserve_data`, то должна выбрасываться ошибка `KeyError`

Ещё надо сделать так, чтобы был закрыт доступ извне к `_secret_data` — на то она и "secret" :)
```python
storage = Storage({'apple': 2})

print(storage['apple'])     # 2
print(storage['potato'])    # 100
print(storage['supplier'])  # Возникает ошибка KeyError

storage._secret_data        # Возникает ошибка AttributeError
```
